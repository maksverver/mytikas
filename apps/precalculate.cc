// Precalculates some constant data used in state.cc

#include "state.h"

#include <cassert>
#include <iomanip>
#include <iostream>
#include <vector>

namespace {

std::vector<field_t> neighbors_data;
std::vector<size_t> neighbors_index;

static void Main() {
    neighbors_index.push_back(0);
    for (int src = 0; src < FIELD_COUNT; ++src) {
        auto [r, c] = FieldCoords(src);
        for (int rr = r - 1; rr <= r + 1; ++rr) {
            for (int cc = c - 1; cc <= c + 1; ++cc) {
                int dst = FieldIndex(rr, cc);
                if (dst != src && dst != -1) {
                    neighbors_data.push_back(dst);
                }
            }
        }
        neighbors_index.push_back(neighbors_data.size());
    }
    assert(neighbors_index.size() == FIELD_COUNT + 1);

    // Print C++ source code
    std::cout << "// Generated by precalculate.cc\n";
    std::cout << "const field_t neighbors_data[] = {\n";
    for (size_t i = 0; i < neighbors_data.size(); ++i) {
        if (i % 12 == 0) std::cout << "    ";
        std::cout << std::setw(4) << static_cast<int>(neighbors_data[i]) << ',';
        if ((i + 1) == neighbors_data.size() || (i + 1) % 12 == 0) std::cout << "\n";
    }
    std::cout << "};\n";
    std::cout << "extern const size_t neighbors_index[FIELD_COUNT + 1] = {\n";
    for (size_t i = 0; i < neighbors_index.size(); ++i) {
        if (i % 12 == 0) std::cout << "    ";
        std::cout << std::setw(4) << neighbors_index[i] << ',';
        if ((i + 1) == neighbors_index.size() || (i + 1) % 12 == 0) std::cout << "\n";
    }
    std::cout << "};\n";
}

}  // namespace

int main() {
    Main();
}
