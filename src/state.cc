#include "state.h"

#include <algorithm>
#include <iostream>
#include <string>
#include <string_view>

constexpr Dir knight_dirs[8] = {
    Dir{ -2, -1},
    Dir{ -2, +1},
    Dir{ -1, -2},
    Dir{ -1, +2},
    Dir{ +1, -2},
    Dir{ +1, +2},
    Dir{ +2, -1},
    Dir{ +2, +1},
};

constexpr Dir all8_dirs[8] = {
    // Orthogonal dirs
    Dir{ -1,  0},
    Dir{  0, +1},
    Dir{  0, -1},
    Dir{ +1,  0},
    // Diagonal dirs
    Dir{ -1, -1},
    Dir{ -1, +1},
    Dir{ +1, -1},
    Dir{ +1, +1},
};

constexpr std::span<const Dir, 4> ortho_dirs{&all8_dirs[0], &all8_dirs[4]};
constexpr std::span<const Dir, 4> diag_dirs{&all8_dirs[4], &all8_dirs[8]};
constexpr std::span<const Dir, 0> no_dirs;

std::span<const Dir> GetDirs(Dirs dirs) {
    switch (dirs & 7) {
    case Dirs::NONE:       return no_dirs;
    case Dirs::ORTHOGONAL: return ortho_dirs;
    case Dirs::DIAGONAL:   return diag_dirs;
    case Dirs::ALL8:       return all8_dirs;
    case Dirs::KNIGHT:     return knight_dirs;
    default:
       assert(false);
       return no_dirs;
    }
}

const int8_t field_index_by_coords[BOARD_SIZE][BOARD_SIZE] = {
    { -1, -1, -1, -1,  0, -1, -1, -1, -1 },
    { -1, -1, -1,  1,  2,  3, -1, -1, -1 },
    { -1, -1,  4,  5,  6,  7,  8, -1, -1 },
    { -1,  9, 10, 11, 12, 13, 14, 15, -1 },
    { 16, 17, 18, 19, 20, 21, 22, 23, 24 },
    { -1, 25, 26, 27, 28, 29, 30, 31, -1 },
    { -1, -1, 32, 33, 34, 35, 36, -1, -1 },
    { -1, -1, -1, 37, 38, 39, -1, -1, -1 },
    { -1, -1, -1, -1, 40, -1, -1, -1, -1 },
};

const uint8_t coords_by_field_index[FIELD_COUNT] = {
#define _(r, c) ((r << 4) | c)
                                     _(0,4),
                             _(1,3), _(1,4), _(1,5),
                     _(2,2), _(2,3), _(2,4), _(2,5), _(2,6),
             _(3,1), _(3,2), _(3,3), _(3,4), _(3,5), _(3,6), _(3,7),
    _(4, 0), _(4,1), _(4,2), _(4,3), _(4,4), _(4,5), _(4,6), _(4,7), _(4,8),
             _(5,1), _(5,2), _(5,3), _(5,4), _(5,5), _(5,6), _(5,7),
                     _(6,2), _(6,3), _(6,4), _(6,5), _(6,6),
                             _(7,3), _(7,4), _(7,5),
                                     _(8,4),
#undef _
};

const char *field_names[FIELD_COUNT] = {
                            "e1",
                      "d2", "e2", "f2",
                "c3", "d3", "e3", "f3", "g3",
          "b4", "c4", "d4", "e4", "f4", "g4", "h4",
    "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "i5",
          "b6", "c6", "d6", "e6", "f6", "g6", "h6",
                "c7", "d7", "e7", "f7", "g7",
                      "d8", "e8", "f8",
                            "e9",

};

// Generated by precalculate.cc
const field_t neighbors_data[] = {
       1,   2,   3,   0,   2,   4,   5,   6,   0,   1,   3,   5,
       6,   7,   0,   2,   6,   7,   8,   1,   5,   9,  10,  11,
       1,   2,   4,   6,  10,  11,  12,   1,   2,   3,   5,   7,
      11,  12,  13,   2,   3,   6,   8,  12,  13,  14,   3,   7,
      13,  14,  15,   4,  10,  16,  17,  18,   4,   5,   9,  11,
      17,  18,  19,   4,   5,   6,  10,  12,  18,  19,  20,   5,
       6,   7,  11,  13,  19,  20,  21,   6,   7,   8,  12,  14,
      20,  21,  22,   7,   8,  13,  15,  21,  22,  23,   8,  14,
      22,  23,  24,   9,  17,  25,   9,  10,  16,  18,  25,  26,
       9,  10,  11,  17,  19,  25,  26,  27,  10,  11,  12,  18,
      20,  26,  27,  28,  11,  12,  13,  19,  21,  27,  28,  29,
      12,  13,  14,  20,  22,  28,  29,  30,  13,  14,  15,  21,
      23,  29,  30,  31,  14,  15,  22,  24,  30,  31,  15,  23,
      31,  16,  17,  18,  26,  32,  17,  18,  19,  25,  27,  32,
      33,  18,  19,  20,  26,  28,  32,  33,  34,  19,  20,  21,
      27,  29,  33,  34,  35,  20,  21,  22,  28,  30,  34,  35,
      36,  21,  22,  23,  29,  31,  35,  36,  22,  23,  24,  30,
      36,  25,  26,  27,  33,  37,  26,  27,  28,  32,  34,  37,
      38,  27,  28,  29,  33,  35,  37,  38,  39,  28,  29,  30,
      34,  36,  38,  39,  29,  30,  31,  35,  39,  32,  33,  34,
      38,  40,  33,  34,  35,  37,  39,  40,  34,  35,  36,  38,
      40,  37,  38,  39,
};
extern const size_t neighbors_index[FIELD_COUNT + 1] = {
       0,   3,   8,  14,  19,  24,  31,  39,  46,  51,  56,  63,
      71,  79,  87,  94,  99, 102, 108, 116, 124, 132, 140, 148,
     154, 157, 162, 169, 177, 185, 193, 200, 205, 210, 217, 225,
     232, 237, 242, 248, 253, 256,
};


#define NO_DIRS     Dirs::NONE
#define ORTHO       Dirs::ORTHOGONAL
#define DIAG        Dirs::DIAGONAL
#define ALL8        Dirs::ALL8
#define KNIGHT      Dirs::KNIGHT
#define DIRECT(d)   (static_cast<Dirs>(d | Dirs::DIRECT))

// Must keep this in sync with the Gods enum, and with the pantheon in mytikas.js.
constexpr GodInfo pantheon[GOD_COUNT] = {
    // name        id  emoji  hit mov dmg rng  mov_dirs         atk_dirs        aura
    {"Zeus",       'Z', "‚ö°Ô∏è", 10,   1, 10,  3, ALL8,            DIRECT(ORTHO),  UNAFFECTED   },
    {"Hephaestus", 'H', "üî®",  9,   2,  7,  2, ORTHO,           DIRECT(ORTHO),  DAMAGE_BOOST },
    {"hEra",       'E', "üë∏",  8,   2,  5,  2, DIAG,            DIAG,           UNAFFECTED   },
    {"Poseidon",   'P', "üî±",  7,   3,  4,  0, ORTHO,           NO_DIRS,        UNAFFECTED   },
    {"apOllo",     'O', "üèπ",  6,   2,  2,  3, ALL8,            ALL8,           UNAFFECTED   },
    {"Aphrodite",  'A', "üåπ",  6,   3,  6,  1, ALL8,            ALL8,           UNAFFECTED   },
    {"aRes",       'R', "‚öîÔ∏è",  5,   3,  5,  3, DIRECT(ALL8),    DIRECT(ALL8),   UNAFFECTED   },
    {"herMes",     'M', "ü™Ω",  5,   3,  3,  2, ALL8,            DIRECT(ALL8),   SPEED_BOOST  },
    {"Dionysus",   'D', "üçá",  4,   1,  4,  0, KNIGHT,          NO_DIRS,        UNAFFECTED   },
    {"arTemis",    'T', "ü¶å",  4,   2,  4,  2, ALL8,            DIRECT(DIAG),   UNAFFECTED   },
    {"hadeS",      'S', "üêï",  3,   3,  3,  1, DIRECT(ALL8),    NO_DIRS,        UNAFFECTED   },
    {"atheNa",     'N', "üõ°Ô∏è",  3,   1,  3,  3, ALL8,            DIRECT(ALL8),   SHIELDED     },
};


God GodById(char ch) {
    int i = 0;
    while (i < GOD_COUNT && pantheon[i].ascii_id != ch) ++i;
    return static_cast<God>(i);
}

State State::InitialWithSummonable(std::array<god_mask_t, 2> summonable) {
    State state;
    state.player = LIGHT;
    std::copy_n(summonable.data(), summonable.size(), state.summonable);
    for (int p = 0; p < 2; ++p) {
        for (int g = 0; g < GOD_COUNT; ++g) {
            state.gods[p][g] = GodState{
                .hp = pantheon[g].hit,
                .fi = -1,
                .fx = UNAFFECTED,
            };
        }
    }
    std::fill_n(state.fields, FIELD_COUNT, FieldState::UNOCCUPIED);
    return state;
}

// State encoding
//
// States are encoded as a string of base-64 digits, at least 25, at most 49.
//
//  - 1 digit: next player (0/'A' for light, 1/'B' for dark)
//  - for each player
//      - for each god
//          - 1 digit:
//              0..40      field index: alive and in play
//              41 ('p')   dead
//              42 ('q')   summonable
//              43 ('r')   reserved (alive but not yet summonable)
//          - 1 digit (included only if god is in play)
//              bit    0: chained (0/1)
//              bit 1..5: hit points left
//              bit    6: 0 (unused)
//

// Base 64 alphabet used by state encoding. This is the URL-safe base-64
// alphabet which uses '-' and '_' as the last two digits, though currently
// these are never used in a valid encoded state.
constexpr std::string_view base64_digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

std::string State::Encode() const {
    std::string res;
    res += base64_digits[player];
    for (int p = 0; p < 2; ++p) {
        for (int g = 0; g < GOD_COUNT; ++g) {
            const auto &gs = gods[p][g];
            if (gs.fi != -1) {  // in play
                res += base64_digits[gs.fi];
                // Status effects except for CHAINED can be inferred from
                // adjacent characters, so we only encode CHAINED:
                res += base64_digits[(gs.hp << 1) | ((gs.fx & CHAINED) ? 1 : 0)];
            } else if (gs.hp == 0) {  // dead
                res += base64_digits[FIELD_COUNT + 0];
            } else if ((summonable[p] & GodMask((God) g)) != 0) {  // summonable
                res += base64_digits[FIELD_COUNT + 1];
            } else {  // reserved
                res += base64_digits[FIELD_COUNT + 2];
            }
        }
    }
    return res;
}

constexpr bool debug_decode = true;

// Keep this in sync with decodeStateString() in state.ts
std::optional<State> State::Decode(std::string_view sv) {
    size_t pos = 0;
    auto read = [&]<class T>(T &t, int lim) -> bool {
        assert(0 < lim && lim <= 64);
        if (pos >= sv.size()) {
            if (debug_decode) {
                std::cerr << "Decode(\"" << sv << "\"): read past end of string\n";
            }
            return false;
        }
        auto i = base64_digits.find(sv[pos++]);
        if (i >= lim) {
            if (debug_decode) {
                std::cerr
                    << "Decode(\"" << sv << "\"): base64 value " << i
                    << " exceeds limit " << lim << " at pos " << pos << "\n";
            }
            return false;
        }
        t = static_cast<T>(i);
        return true;
    };
    State state = State::InitialNoneSummonable();
    if (!read(state.player, 2)) return {};
    for (int p = 0; p < 2; ++p) {
        for (int g = 0; g < GOD_COUNT; ++g) {
            auto &gs = state.gods[p][g];
            int fi;
            if (!read(fi, FIELD_COUNT + 3)) return {};
            if (fi < FIELD_COUNT) {  // in play
                int hpfx;
                if (!read(hpfx, (pantheon[g].hit + 1)*2)) return {};
                gs.hp = hpfx >> 1;
                gs.fx = (hpfx & 1) ? CHAINED : UNAFFECTED;
                state.Place((Player)p, (God)g, fi);
            } else if (fi == FIELD_COUNT) {  // dead
                gs.hp = 0;
            } else if (fi == FIELD_COUNT + 1) {  // summonable
                state.summonable[p] |= GodMask((God)g);
            } else {
                assert(fi == FIELD_COUNT + 2);  // reserved
            }
        }
    }
    if (pos != sv.size()) return {};  // unexpected trailing data
    return state;
}

void State::Place(Player player, God god, field_t field) {
    assert(!fields[field].occupied);
    assert(gods[player][god].fi == -1);
    summonable[player] &= ~GodMask(god);
    fields[field] = FieldState {
        .occupied = true,
        .player   = player,
        .god      = god,
    };
    gods[player][god].fi = field;

    // Apply status effects from this god to neighbors:
    if (StatusFx aura = pantheon[god].aura; aura != UNAFFECTED) {
        for (field_t f : Neighbors(field)) {
            if (PlayerAt(f) == player) AddFx(player, GodAt(f), aura);
        }
    }

    // Apply status effects from neighbors to this god:
    for (field_t f : Neighbors(field)) {
        if (PlayerAt(f) == player) {
            if (StatusFx aura = pantheon[GodAt(f)].aura; aura != UNAFFECTED) {
                AddFx(player, god, aura);
            }
        }
    }
}

void State::Remove(Player player, God god, field_t field) {
    GodState &gs = gods[player][god];
    gs.fi = -1;
    gs.fx = UNAFFECTED,
    fields[field] = FieldState::UNOCCUPIED;

    // Remove status effects conferred by this god:
    if (StatusFx aura = pantheon[god].aura; aura != UNAFFECTED) {
        for (field_t f : Neighbors(field)) {
            if (PlayerAt(f) == player) RemoveFx(player, GodAt(f), aura);
        }
    }

    // When Hades is removed, remove CHAINED effect from adjacent enemies.
    if (god == HADES) {
        Player opponent = Other(player);
        for (field_t f : Neighbors(field)) {
            if (PlayerAt(f) == opponent) {
                Unchain(opponent, GodAt(f));
            }
        }
    }
}

void State::Move(Player player, God god, field_t dst) {
    assert(dst != -1 && !fields[dst].occupied);

    Unchain(player, god); // moving always removes Hades chain

    GodState &gs = gods[player][god];
    field_t src = gs.fi;
    assert(src != -1);
    gs.fi = dst;
    fields[dst] = fields[src];
    fields[src] = FieldState::UNOCCUPIED;

    // Update status effects by iterating neighboring fields that
    // are removed and neighboring fields that are added.
    //
    // Note that we need to account for both the fx this piece
    // grants to its neighbors, and fx it receives.
    //
    // Hades is a special case in that it applies to enemies and it is
    // removed automatically but NOT granted automatically.
    NeighborsDiff(src, dst,
        [&](field_t f) {
            // Old neighbor removed.
            if (PlayerAt(f) == player) {
                God ally = GodAt(f);
                RemoveFx(player, ally, pantheon[god].aura);
                RemoveFx(player, god, pantheon[ally].aura);
            } else if (god == HADES) {
                God enemy = GodAt(f);
                if (enemy != GOD_COUNT) {
                    // Unchain enemy when Hades moves away.
                    Unchain(Other(player), enemy);
                }
            }
        },
        [&](field_t f) {
            // New neighbor added.
            if (PlayerAt(f) == player) {
                God ally = GodAt(f);
                AddFx(player, ally, pantheon[god].aura);
                AddFx(player, god, pantheon[ally].aura);
            }
        });
}

void State::DealDamage(Player player, God god, int damage) {
    assert(fi(player, god) != -1);
    auto &hp = gods[player][god].hp;
    if (hp > damage) {
        hp -= damage;
    } else {
        Kill(player, god);
    }
}

void State::Kill(Player player, God god) {
    field_t field = fi(player, god);
    gods[player][god].hp = 0;
    Remove(player, god, field);
}

void State::SetHpForTest(Player player, God god, int hp) {
    assert(0 < hp && hp <= pantheon[god].hit);
    gods[player][god].hp = hp;
}

void State::DecHpForTest(Player player, God god, int dmg) {
    SetHpForTest(player, god, hp(player, god) - dmg);
}

god_mask_t State::PlayerGods(Player player) const {
    god_mask_t mask = summonable[player];
    for (int god = 0; god < GOD_COUNT; ++god) {
        if (gods[player][god].fi != -1) mask |= GodMask((God) god);
    }
    return mask;
}

bool State::IsAlmostOver() const {
    return IsOver() || !PlayerGods(LIGHT) || !PlayerGods(DARK);
}

int State::AlmostWinner() const {
    if (int w = Winner(); w != -1) return w;

    auto p1 = PlayerGods(LIGHT);
    auto p2 = PlayerGods(DARK);
    if (p1 != 0 && p2 != 0) return false;

    // When only one player has pieces left, the player with pieces left can win,
    // unless they only have Hera left and she's on a field from which she
    // cannot move to the enemy's gate (this can happen if Aphrodite previously
    // swapped with her).
    if (p1 != 0 && p2 == 0) {
        if (p1 == (1 << HERA) &&
                FieldParity(fi(LIGHT, HERA)) != FieldParity(gate_index[DARK])) {
            return -1;
        }
        return LIGHT;
    }
    if (p1 == 0 && p2 != 0) {
        if ( p2 == (1 << HERA) &&
                FieldParity(fi(DARK, HERA)) != FieldParity(gate_index[LIGHT])) {
            return -1;
        }
        return DARK;
    }
    return -1;
}

std::ostream &operator<<(std::ostream &os, const State::DebugPrint &dbg) {
    const State &s = dbg.state;
    os << "player=" << (int) s.player << '\n';
    for (int p = 0; p < 2; ++p) {
        os << "summonable=" << (unsigned) s.summonable[p] << '\n';
        for (int g = 0; g < GOD_COUNT; ++g) {
            const GodState &gs = s.gods[p][g];
            os  << "gods[" << p << "][" << g << "]:"
                << " hp=" << (int) gs.hp
                << " fi=" << (int) gs.fi
                << " fx=" << (int) gs.fx
                << '\n';
        }
    }
    for (int f = 0; f < FIELD_COUNT; ++f) {
        const FieldState &fs = s.fields[f];
        os  << "fields[" << f << "] ="
            << " occupied=" << (int) fs.occupied
            << " player=" << (int) fs.player
            << " god=" << (int) fs.god
            << '\n';
    }
    return os;
}
